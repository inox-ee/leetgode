# Next Permutations

## 私の解

最下位桁から隣り合う数の大小比較し、最初に `a[i-1] < a[i]` なる `i` を探す。 **<- ここまでは良かった**
これ以降、swap を用いて並べ替えを行おうと考えたが、法則性を間違えていたので WA だった。

## 解答例１

1. `[1, 5, 8, 4, 7, 6, 5, 3, 1]` を例にとる。
2. `a[i-1] < a[i]` なる最大の i を探す
3. 次に `a[i-1]` の次に大きい数を `a[i:]` から探す(=`a[j]` とする)
4. `a[i-1]` と `a[j]` を入れ替え、`a[i:]` を逆順に並べ替える **<- これが足りなかった**

---

## 補足

### _lexicographically_

辞書順序的に

### _in place アルゴリズム_

計算機科学において、データ構造の変換を行う際に追加の記憶領域をほとんど使わずに行うアルゴリズムのこと。

以下例

```
[ダメな解]
# これは b[0...n] の記憶領域を必要とする
function reverse(a[0...n])
  allocate b[0...n]
  for i from 0 to n
    b[n-i] = a[i]
  return b

[期待の解]
# これは a[0...n] の記憶領域のみで完結する
function reverse_in_place(a[0...n])
  for i from 0 to floor(n/2)
    swap(a[i], a[n-i])
```

ソートの中でも、バブルソートやヒープソートは in-place アルゴリズムである。一方クイックソートは議論に挙げられることも多いが、再帰の深さが最悪 $O(n)$ に達し、$O(n\log n)$ の領域を消費する。
