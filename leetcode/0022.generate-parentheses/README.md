# Generate Parentheses

## 私の解答

- 解法：Brute Force
- 計算量：O(2^(2n) \* n)

そもそも解法が思いつかなかったが、combination の実装も思いつかなかった。

## 解答例１

- 解法：backtracking

backtracking により、正誤判定をしながら全通り探索できる。
思いついてはいたが、再帰という発想がなかった…

### backtracking とは

制約充足問題を探索する戦略の一種。一種の深さ優先探索とも言える。
一般に **再帰呼び出し関数** として実装される。

代表例：0/1 ナップサック問題、N クイーン問題

### backtracking 実装のヒントになるかもしれない考え方

- 実行してほしい順に樹形図を書いてみる
- 分岐は、複数の if 文 (=**else ではなく、連続させる**) で表現する
- 各再帰関数は無理やり返り値を考えなくとも、`return void` とし、答えを格納する配列をポインタで渡すのが楽だったりする。
